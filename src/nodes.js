/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { updateAttribute } from './attributes';
import {
    getData,
    initData
} from './node_data';
import { createMap } from './util';
import { assertUniqueKey } from './assertions';


/**
 * Gets the namespace to create an element (of a given tag) in.
 * @param {string} tag The tag to get the namespace for.
 * @param {?Node} parent
 * @return {?string} The namespace to create the tag in.
 */
const getNamespaceForTag = function(tag, parent) {
  if (tag === 'svg') {
    return 'http://www.w3.org/2000/svg';
  }

  if (getData(parent).nodeName === 'foreignObject') {
    return null;
  }

  return parent.namespaceURI;
};


/**
 * Creates an Element.
 * @param {Document} doc The document with which to create the Element.
 * @param {?Node} parent
 * @param {string} tag The tag for the Element.
 * @param {?string=} key A key to identify the Element.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element.
 * @return {!Element}
 */
const createElement = function(doc, parent, tag, key, statics) {
  const namespace = getNamespaceForTag(tag, parent);
  let el;

  if (namespace) {
    el = doc.createElementNS(namespace, tag);
  } else {
    el = doc.createElement(tag);
  }

  initData(el, tag, key);

  if (statics) {
    for (let i = 0; i < statics.length; i += 2) {
      updateAttribute(el, /** @type {!string}*/(statics[i]), statics[i + 1]);
    }
  }

  return el;
};


/**
 * Creates a Text Node.
 * @param {Document} doc The document with which to create the Element.
 * @return {!Text}
 */
const createText = function(doc) {
  const node = doc.createTextNode('');
  initData(node, '#text', null);
  return node;
};


/**
 * Creates a mapping that can be used to look up children using a key.
 * @param {?Node} el
 * @return {!Object<string, !Element>} A mapping of keys to the children of the
 *     Element.
 */
const createKeyMap = function(el) {
  const map = createMap();
  const children = el.children;
  const count = children.length;

  for (let i = 0; i < count; i += 1) {
    const child = children[i];
    const key = getData(child).key;

    if (key) {
      map[key] = child;
    }
  }

  return map;
};


/**
 * Retrieves the mapping of key to child node for a given Element, creating it
 * if necessary.
 * @param {?Node} el
 * @return {!Object<string, !Node>} A mapping of keys to child Elements
 */
const getKeyMap = function(el) {
  const data = getData(el);

  if (!data.keyMap) {
    data.keyMap = createKeyMap(el);
  }

  return data.keyMap;
};


/**
 * Retrieves a child from the parent with the given key.
 * @param {?Node} parent
 * @param {?string=} key
 * @return {?Node} The child corresponding to the key.
 */
const getChild = function(parent, key) {
  return key ? getKeyMap(parent)[key] : null;
};


/**
 * Registers an element as being a child. The parent will keep track of the
 * child using the key. The child can be retrieved using the same key using
 * getKeyMap. The provided key should be unique within the parent Element.
 * @param {?Node} parent The parent of child.
 * @param {string} key A key to identify the child with.
 * @param {!Node} child The child to register.
 */
const registerChild = function(parent, key, child) {
  getKeyMap(parent)[key] = child;
};


/**
 * Asserts that the key has not yet been used for this parent in this patch.
 * @param {!Node} parent the parent node which contains the keyed element.
 * @param {string} key the key to use.
 */
const useKey = function(parent, key) {
  const usedKeys = getData(parent).usedKeys;
  const patchKeys = usedKeys[usedKeys.length - 1];

  assertUniqueKey(key, patchKeys);
  patchKeys[key] = true;
};


/**
 * Adds a new usedKeys map for the current patch context.
 * @param {!Node} node the node to add keys.
 */
const trackUsedKeys = function(node) {
  const keys = createMap();
  const data = getData(node);
  data.usedKeys.push(keys);
};


/**
 * Pops the currently used keys for this patch context.
 * @param {!Node} node the node to clear keys from.
 */
const clearUsedKeys = function(node) {
  const data = getData(node);
  data.usedKeys.pop();
};


/** */
export {
  createElement,
  createText,
  getChild,
  registerChild,
  useKey,
  clearUsedKeys,
  trackUsedKeys
};
